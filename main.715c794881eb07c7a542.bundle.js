(self.webpackChunkref_talk=self.webpackChunkref_talk||[]).push([[179],{8175:(e,t,n)=>{"use strict";n.d(t,{nL:()=>h,DI:()=>k,gK:()=>d,w3:()=>i,e:()=>f,LZ:()=>c});var a=n(7401),r=n(5579),o=n.n(r);function u(){return a.useReducer((()=>[]))[1]}function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function s({children:e,...t}){return a.createElement("button",l({className:"button-component"},t),e)}function c({size:e=24}){return a.createElement("span",{className:"spacer",style:{marginBottom:e}})}function i(){const e=a.useRef(0),t=u();return a.createElement("div",null,a.createElement("h1",null,e.current),a.createElement(s,{onClick:()=>e.current--},"-"),a.createElement(s,{onClick:()=>e.current++},"+"),a.createElement(s,{onClick:t},"Rerender"))}let p=0;function d(){const e=u();return a.createElement("div",null,a.createElement("h1",null,p),a.createElement(s,{onClick:()=>p--},"-"),a.createElement(s,{onClick:()=>p++},"+"),a.createElement(s,{onClick:e},"Rerender"))}function h(){const e=a.useRef(null),[t,n]=a.useState(!1),[r,o]=a.useState(e.current);return a.useLayoutEffect((()=>{o(e.current&&e.current.nodeName)}),[t]),a.createElement("div",null,!t&&a.createElement("div",{ref:e},"Hello im a div element 👋"),a.createElement("span",null,r?`Node name is: ${r}`:`Node is ${r}`),a.createElement(s,{onClick:()=>n((e=>!e))},"Toggle Hide"))}const m=a.forwardRef(((e,t)=>{const n=a.useRef(null);return a.useImperativeHandle(t,(()=>({focus:()=>n.current.focus()})),[]),a.createElement("input",l({style:{padding:8,borderRadius:8},ref:n},e))}));function f(){const e=a.useRef(null);return a.createElement("div",null,a.createElement(m,{ref:e,placeholder:"useImperativeHandle"}),a.createElement(s,{onClick:()=>e.current.focus()},"Focus"))}function k(){const[e,t]=a.useState(!1),{width:n,height:r}=function(){const[e,t]=a.useState({width:void 0,height:void 0});return a.useEffect((()=>{function e(){t({width:window.innerWidth,height:window.innerHeight})}return window.addEventListener("resize",e),e(),()=>window.removeEventListener("resize",e)}),[]),e}(),u=a.useRef(0);return a.createElement("div",null,a.createElement(s,{onClick:()=>{t(!0),clearTimeout(u.current),u.current=setTimeout((()=>{t(!1)}),1e4)}},"Click here!"),e?a.createElement(o(),{width:n,height:r}):null)}},3765:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>l,backgrounds:()=>s,fragmentSteps:()=>c,fusumaProps:()=>i,default:()=>d});var a=n(8175),r=n(7401),o=n(9332);function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}const l=[e=>(0,o.kt)(r.Fragment,null,(0,o.kt)("h1",null,"useRef and useImperativeHandle hooks 🎣"),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("p",null,"Hello 👋!! Welcome to the useRef and useImperativeHandle talk,\nin this talk i will cover everything, well almost everything about useRef and useImperativeHandle."),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("p",null,"Those are pretty simple hooks but they are really powerful, specially useRef."),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The API's"),(0,o.kt)("li",{parentName:"ul"},"When to use"),(0,o.kt)("li",{parentName:"ul"},"When not to use"),(0,o.kt)("li",{parentName:"ul"},"Common questions")),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"\nconst ref = useRef(null)\n\nconst handlers = useImperativeHandle(ref, () => ({ handle: () => (...) }), [])\n\n")))],s=[0],c=[0],i=[{classes:"title",sectionTitle:"Intro"}],p={};function d({components:e,...t}){return(0,o.kt)("wrapper",u({},p,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",null,"useRef and useImperativeHandle hooks 🎣"),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("p",null,"Hello 👋!! Welcome to the useRef and useImperativeHandle talk,\nin this talk i will cover everything, well almost everything about useRef and useImperativeHandle."),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("p",null,"Those are pretty simple hooks but they are really powerful, specially useRef."),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The API's"),(0,o.kt)("li",{parentName:"ul"},"When to use"),(0,o.kt)("li",{parentName:"ul"},"When not to use"),(0,o.kt)("li",{parentName:"ul"},"Common questions")),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"\nconst ref = useRef(null)\n\nconst handlers = useImperativeHandle(ref, () => ({ handle: () => (...) }), [])\n\n")))}d.isMDXComponent=!0},4788:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>s,backgrounds:()=>c,fragmentSteps:()=>i,fusumaProps:()=>p,default:()=>h});var a=n(8175),r=n(7178),o=n(7401),u=n(9332);function l(){return(l=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}const s=[e=>(0,u.kt)(o.Fragment,null,(0,u.kt)("h1",null,"useRef"),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"useRef is a really underestimated hook that provides you a way to create a mutable object that persists between renders.\nThat way you can keep values around to use for internal purposes on your components and hooks. Its similar to ",(0,u.kt)("inlineCode",{parentName:"p"},"useState")," in the fact\nthat it holds some sort of state for the component. "),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("img",{src:r}),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},'\nconst ref = useRef("🐍");\n\nref.current === 🐍" // true\n\n')),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"This will create a object that has a ",(0,u.kt)("inlineCode",{parentName:"p"},"current")," property on it, and thats where you can store\nwhat ever values you want. The API is pretty simple, the value you pass into the hook will be set as the internal value,\nnote this value passed in will only be set in the first render.")),e=>(0,u.kt)(o.Fragment,null,(0,u.kt)("p",null,"Mutating the useRef object will not trigger a rerender and thats its gratest feature. The example below shows the\nimplementation of a counter using useRef. Note that this will not work like useState does."),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nfunction CounterRef() {\n  const countRef = React.useRef(0);\n  const rerender = useRerender();\n  return (\n    <div>\n      <h1>{countRef.current}</h1>\n      <button onClick={() => countRef.current--}>-</button>\n      <button onClick={() => countRef.current++}>+</button>\n      <button onClick={rerender}>Rerender</button>\n    </div>\n  );\n}\n\n")),(0,u.kt)(a.w3,{mdxType:"CounterRef",mdxType:"CounterRef"})),e=>(0,u.kt)(o.Fragment,null,(0,u.kt)("p",null,"Ok, and now you might be wondering why would you need useRef? Can't you just have a variable outside your component\nthat you can use? Well you could, but it would not work as you would expect."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nlet counter = 0;\n\nexport function CounterLet() {\n  const rerender = useRerender();\n  return (\n    <div>\n      <h1>{counter}</h1>\n      <Button onClick={() => counter--}>-</Button>\n      <Button onClick={() => counter++}>+</Button>\n      <Button onClick={rerender}>Rerender</Button>\n    </div>\n  );\n}\n\n")),(0,u.kt)(a.gK,{mdxType:"CounterLet",mdxType:"CounterLet"}),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"👉🏼 In the next slide we will see the issue with this approach.")),e=>(0,u.kt)(o.Fragment,null,(0,u.kt)("h2",null,"The issue with module level variables."),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"Play around with these examples, two examples of the same component"),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\n// let counter = ...\n<CounterLet/>\n<CounterLet/>\n\n")),(0,u.kt)(a.gK,{mdxType:"CounterLet",mdxType:"CounterLet"}),(0,u.kt)(a.gK,{mdxType:"CounterLet",mdxType:"CounterLet"}),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"You can quickly see the issue here. In this case they are sharing the same instance of the counter variable."),(0,u.kt)("p",null,"So now we can see how important useRef is to give use persistency and isolation in our components.")),e=>(0,u.kt)(o.Fragment,null,(0,u.kt)("h1",null,"Accessing DOM"),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"The most common use case you will see for useRef is for accessing te undelying DOM element\nthat is behind the JSX we write. That way we can interact directly with the DOM element if needed."),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"Note that you should only manipulate the element inside the ref after render. Since the DOM element has not been\ncreated yet, before the render occurs."),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nexport function AccessDOM() {\n  const domRef = React.useRef(null);\n  const [hide, setHide] = React.useState(false);\n  const [el, setEl] = React.useState(domRef.current);\n\n  const toggle = () => setHide((h) => !h);\n\n  React.useLayoutEffect(() => {\n    setEl(domRef.current &&  domRef.current.nodeName )\n  }, [hide]);\n\n  return (\n    <div>\n      {!hide && <div ref={domRef}>Hello 👋</div>}\n      <span >{el ? `Node name is a ${el}` : `Node is ${el}`}</span>\n      <Button onClick={toggle}>Toggle Hide</Button>\n    </div>\n  );\n}\n\n")),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)(a.nL,{mdxType:"AccessDOM",mdxType:"AccessDOM"})),e=>(0,u.kt)(o.Fragment,null,(0,u.kt)("h1",null,"useRef and dependency array"),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"You can use the useRef hook as a bail out for passing something into the dependency array\nthat you know will be different every render. You want to have the latest value of the unstable value,\nbut not invalidate the dependency array just because of it."),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"In this case below you will have this useEffect run on every render\njust because the inline callback is a new one on every render. If you only omit from the\ndependency array and break the rules of hooks you might end up with a stale function inside the useEffect,\nthat point to stale variables from previous renders."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nconst useHook(aInlineCallback) {\n  // more stuff here\n  React.useEffect(() => {\n    aInlineCallback(other, stable, deps)\n  }, [other, stable, deps, aInlineCallback])\n  // more stuff here\n}\n// hook usage\nuseHook(() => (...))\n\n"))),e=>(0,u.kt)(o.Fragment,null,(0,u.kt)("h2",null,"How to bail out of dependency array."),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"In this case below you will have the useEffect run only when the stable values on the dependency array changes,\nbut you still get the benefits of having the most up to date funtion. "),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("p",null,"NOTE: if you want you effect to run when\nthe function changes you should tell the user to pass the function wrapped in useCallback."),(0,u.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nconst useHook(aInlineCallback) {\n  const callbackRef = React.useRef(aInlineCallback);\n\n  React.useLayoutEffect(() => {\n    callbackRef.current = aInlineCallback\n  });\n  // more stuff here\n  React.useEffect(() => {\n    callbackRef.current(other, stable, deps)\n  }, [other, stable, deps]);\n  // more stuff here\n}\n// hook usage\nuseHook(() => (...));\n\n")))],c=[0,0,0,0,0,0,0],i=[0,0,0,0,0,0,0],p=[{classes:"title",sectionTitle:"useRef"},{},{},{},{sectionTitle:"Accessing the DOM with useRef"},{sectionTitle:"useRef and dependency arrays"},{}],d={};function h({components:e,...t}){return(0,u.kt)("wrapper",l({},d,t,{components:e,mdxType:"MDXLayout"}),(0,u.kt)("h1",null,"useRef"),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"useRef is a really underestimated hook that provides you a way to create a mutable object that persists between renders.\nThat way you can keep values around to use for internal purposes on your components and hooks. Its similar to ",(0,u.kt)("inlineCode",{parentName:"p"},"useState")," in the fact\nthat it holds some sort of state for the component. "),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("img",{src:r}),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},'\nconst ref = useRef("🐍");\n\nref.current === 🐍" // true\n\n')),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"This will create a object that has a ",(0,u.kt)("inlineCode",{parentName:"p"},"current")," property on it, and thats where you can store\nwhat ever values you want. The API is pretty simple, the value you pass into the hook will be set as the internal value,\nnote this value passed in will only be set in the first render."),(0,u.kt)("hr",null),(0,u.kt)("p",null,"Mutating the useRef object will not trigger a rerender and thats its gratest feature. The example below shows the\nimplementation of a counter using useRef. Note that this will not work like useState does."),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nfunction CounterRef() {\n  const countRef = React.useRef(0);\n  const rerender = useRerender();\n  return (\n    <div>\n      <h1>{countRef.current}</h1>\n      <button onClick={() => countRef.current--}>-</button>\n      <button onClick={() => countRef.current++}>+</button>\n      <button onClick={rerender}>Rerender</button>\n    </div>\n  );\n}\n\n")),(0,u.kt)(a.w3,{mdxType:"CounterRef"}),(0,u.kt)("hr",null),(0,u.kt)("p",null,"Ok, and now you might be wondering why would you need useRef? Can't you just have a variable outside your component\nthat you can use? Well you could, but it would not work as you would expect."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nlet counter = 0;\n\nexport function CounterLet() {\n  const rerender = useRerender();\n  return (\n    <div>\n      <h1>{counter}</h1>\n      <Button onClick={() => counter--}>-</Button>\n      <Button onClick={() => counter++}>+</Button>\n      <Button onClick={rerender}>Rerender</Button>\n    </div>\n  );\n}\n\n")),(0,u.kt)(a.gK,{mdxType:"CounterLet"}),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"👉🏼 In the next slide we will see the issue with this approach."),(0,u.kt)("hr",null),(0,u.kt)("h2",null,"The issue with module level variables."),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"Play around with these examples, two examples of the same component"),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\n// let counter = ...\n<CounterLet/>\n<CounterLet/>\n\n")),(0,u.kt)(a.gK,{mdxType:"CounterLet"}),(0,u.kt)(a.gK,{mdxType:"CounterLet"}),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"You can quickly see the issue here. In this case they are sharing the same instance of the counter variable."),(0,u.kt)("p",null,"So now we can see how important useRef is to give use persistency and isolation in our components."),(0,u.kt)("hr",null),(0,u.kt)("h1",null,"Accessing DOM"),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"The most common use case you will see for useRef is for accessing te undelying DOM element\nthat is behind the JSX we write. That way we can interact directly with the DOM element if needed."),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"Note that you should only manipulate the element inside the ref after render. Since the DOM element has not been\ncreated yet, before the render occurs."),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nexport function AccessDOM() {\n  const domRef = React.useRef(null);\n  const [hide, setHide] = React.useState(false);\n  const [el, setEl] = React.useState(domRef.current);\n\n  const toggle = () => setHide((h) => !h);\n\n  React.useLayoutEffect(() => {\n    setEl(domRef.current &&  domRef.current.nodeName )\n  }, [hide]);\n\n  return (\n    <div>\n      {!hide && <div ref={domRef}>Hello 👋</div>}\n      <span >{el ? `Node name is a ${el}` : `Node is ${el}`}</span>\n      <Button onClick={toggle}>Toggle Hide</Button>\n    </div>\n  );\n}\n\n")),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)(a.nL,{mdxType:"AccessDOM"}),(0,u.kt)("hr",null),(0,u.kt)("h1",null,"useRef and dependency array"),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"You can use the useRef hook as a bail out for passing something into the dependency array\nthat you know will be different every render. You want to have the latest value of the unstable value,\nbut not invalidate the dependency array just because of it."),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"In this case below you will have this useEffect run on every render\njust because the inline callback is a new one on every render. If you only omit from the\ndependency array and break the rules of hooks you might end up with a stale function inside the useEffect,\nthat point to stale variables from previous renders."),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nconst useHook(aInlineCallback) {\n  // more stuff here\n  React.useEffect(() => {\n    aInlineCallback(other, stable, deps)\n  }, [other, stable, deps, aInlineCallback])\n  // more stuff here\n}\n// hook usage\nuseHook(() => (...))\n\n")),(0,u.kt)("hr",null),(0,u.kt)("h2",null,"How to bail out of dependency array."),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"In this case below you will have the useEffect run only when the stable values on the dependency array changes,\nbut you still get the benefits of having the most up to date funtion. "),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("p",null,"NOTE: if you want you effect to run when\nthe function changes you should tell the user to pass the function wrapped in useCallback."),(0,u.kt)(a.LZ,{mdxType:"Spacer"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-js"},"\nconst useHook(aInlineCallback) {\n  const callbackRef = React.useRef(aInlineCallback);\n\n  React.useLayoutEffect(() => {\n    callbackRef.current = aInlineCallback\n  });\n  // more stuff here\n  React.useEffect(() => {\n    callbackRef.current(other, stable, deps)\n  }, [other, stable, deps]);\n  // more stuff here\n}\n// hook usage\nuseHook(() => (...));\n\n")))}h.isMDXComponent=!0},3647:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>l,backgrounds:()=>s,fragmentSteps:()=>c,fusumaProps:()=>i,default:()=>d});var a=n(8175),r=n(7401),o=n(9332);function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}const l=[e=>(0,o.kt)(r.Fragment,null,(0,o.kt)("h1",null,"useImperativeHandle ↩️"),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("p",null,"First let look at this quote from the React docs: "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"useImperativeHandle customizes the instance value that is exposed to parent components when using ref. As always, imperative code using refs should be avoided in most cases. useImperativeHandle should be used with forwardRef")),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("p",null,"So in essence useImperativeHandle gives us a way to break the trade mark of React which is one way data flow.\nIt gives you the power to access internal values from the child on the parent component"),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("p",null,"As the first paremeter you get the forwarded ref, the second paremeter is a calback with the value you want to inject in the ref,\nand similar to the useEffect/useLayoutEffect hooks, it has a third paremeter that is a dependency array so you can let the hook know\nwhen it should update the injected values. The undelying implementation of useImperativeHandle uses useLayoutEffect, so it run ",(0,o.kt)("inlineCode",{parentName:"p"},"after")," DOM updates but before paint."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'\nReact.useImperativeHandle(ref, () => "🚀",[]);\n\nref.current === "🚀" // true\n\n'))),e=>(0,o.kt)(r.Fragment,null,(0,o.kt)("h2",null,"Quick example"),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("p",null,"Here you can see how we are able to make the parent component control the child input focus.\nThis API is mostly used for modals, where the state of the modal is held in the child, but you still want\nthe parent to control it."),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'\nconst Input = React.forwardRef((props, ref) => {\n  const inputRef = React.useRef(null)\n\n  React.useImperativeHandle(ref, () => ({ focus: () => inputRef.current.focus() }), []);\n\n  return <input ref={inputRef} {...props} />;\n});\n\nexport function InputFocus() {\n  const inputRef = React.useRef(null);\n\n  return (\n    <div>\n      <Input ref={inputRef} placeholder="useImperativeHandle" />\n      <Button onClick={() => inputRef.current.focus()}>Focus</Button>\n    </div>\n  );\n}\n\n')),(0,o.kt)(a.e,{mdxType:"InputFocus",mdxType:"InputFocus"}))],s=[0,0],c=[0,0],i=[{classes:"title",sectionTitle:"useImperativeHandle"},{}],p={};function d({components:e,...t}){return(0,o.kt)("wrapper",u({},p,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",null,"useImperativeHandle ↩️"),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("p",null,"First let look at this quote from the React docs: "),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"useImperativeHandle customizes the instance value that is exposed to parent components when using ref. As always, imperative code using refs should be avoided in most cases. useImperativeHandle should be used with forwardRef")),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("p",null,"So in essence useImperativeHandle gives us a way to break the trade mark of React which is one way data flow.\nIt gives you the power to access internal values from the child on the parent component"),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("p",null,"As the first paremeter you get the forwarded ref, the second paremeter is a calback with the value you want to inject in the ref,\nand similar to the useEffect/useLayoutEffect hooks, it has a third paremeter that is a dependency array so you can let the hook know\nwhen it should update the injected values. The undelying implementation of useImperativeHandle uses useLayoutEffect, so it run ",(0,o.kt)("inlineCode",{parentName:"p"},"after")," DOM updates but before paint."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'\nReact.useImperativeHandle(ref, () => "🚀",[]);\n\nref.current === "🚀" // true\n\n')),(0,o.kt)("hr",null),(0,o.kt)("h2",null,"Quick example"),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("p",null,"Here you can see how we are able to make the parent component control the child input focus.\nThis API is mostly used for modals, where the state of the modal is held in the child, but you still want\nthe parent to control it."),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'\nconst Input = React.forwardRef((props, ref) => {\n  const inputRef = React.useRef(null)\n\n  React.useImperativeHandle(ref, () => ({ focus: () => inputRef.current.focus() }), []);\n\n  return <input ref={inputRef} {...props} />;\n});\n\nexport function InputFocus() {\n  const inputRef = React.useRef(null);\n\n  return (\n    <div>\n      <Input ref={inputRef} placeholder="useImperativeHandle" />\n      <Button onClick={() => inputRef.current.focus()}>Focus</Button>\n    </div>\n  );\n}\n\n')),(0,o.kt)(a.e,{mdxType:"InputFocus"}))}d.isMDXComponent=!0},9953:(e,t,n)=>{"use strict";n.r(t),n.d(t,{slides:()=>l,backgrounds:()=>s,fragmentSteps:()=>c,fusumaProps:()=>i,default:()=>d});var a=n(8175),r=n(7401),o=n(9332);function u(){return(u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}const l=[e=>(0,o.kt)(r.Fragment,null,(0,o.kt)("h1",null,"The End 🎉"),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)("h2",null,"Thank you for attending!! 👋"),(0,o.kt)(a.LZ,{mdxType:"Spacer",mdxType:"Spacer"}),(0,o.kt)(a.DI,{mdxType:"Confetti",mdxType:"Confetti"}))],s=[0],c=[0],i=[{classes:"title",sectionTitle:"The end"}],p={};function d({components:e,...t}){return(0,o.kt)("wrapper",u({},p,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",null,"The End 🎉"),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)("h2",null,"Thank you for attending!! 👋"),(0,o.kt)(a.LZ,{mdxType:"Spacer"}),(0,o.kt)(a.DI,{mdxType:"Confetti"}))}d.isMDXComponent=!0},5516:(e,t,n)=>{"use strict";n.r(t)},7178:(e,t,n)=>{"use strict";e.exports=n.p+"6fe3585f050ee4901b0f.webp"},3447:(e,t,n)=>{var a={"./0-intro.mdx":3765,"./01-useRef.mdx":4788,"./02-useImperativeHandle.mdx":3647,"./03-end.mdx":9953};function r(e){var t=o(e);return n(t)}function o(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}r.keys=function(){return Object.keys(a)},r.resolve=o,e.exports=r,r.id=3447}},function(e){"use strict";var t;t=e.x,e.x=()=>{var n=t();return[901,921,626].map(e.E),n}},[[7751,666,736],[2069,666,736],[9969,666,736]]]);